function traj = radial_trajectory_girf(kdim,goldenangle,girf_k)
% Compute k-space coordinates [-1;1] for radial acquisitions from the GIRF
% modified gradient waveforms. Assumes a stack-of-stars or 2D radial
% trajectory. Assume image dimensons are derivable from kdim

% Pre-allocate trajectory matrix
traj=zeros(3,kdim(1),kdim(2),prod(kdim([3 5:end])));
    
% Scale girf_k according to kdim
girf_k=cell2mat(girf_k);
girf_k(:,1)=girf_k(:,1)*kdim(1);
girf_k(:,2)=girf_k(:,2)*kdim(1);
girf_k(:,3)=girf_k(:,3)*kdim(3);

% Get radial angles for uniform (rev) or golden angle
if goldenangle > 0
    d_ang=(pi/(((1+sqrt(5))/2)+goldenangle-1));
else
    d_ang=pi/(kdim(2));
end
rad_ang=0:d_ang:d_ang*(kdim(2)-1);

% Line reversal for uniform
if goldenangle == 0
    rad_ang(2:2:end)=rad_ang(2:2:end)+pi;
    rad_ang=mod(rad_ang,2*pi);
end

% Function handle to compute coordinates for every azimuthal angle
k_real=@(theta,k_time)(cos(theta)*k_time);
k_imag=@(theta,k_time)(sin(theta)*k_time);

% Loop over partitions 
for p=1:prod(kdim(4:end))
    traj(1,:,:,p)=repmat(girf_k(:,1),[1 kdim(2)]).*repmat(cos(rad_ang),[kdim(1) 1]);
    traj(2,:,:,p)=repmat(girf_k(:,2),[1 kdim(2)]).*repmat(sin(rad_ang),[kdim(1) 1]);
    traj(3,:,:,p)=
end


% 
% % Loop over all readouts and compute 
% for n=1:num_data
% for ex2=1:Kd{n}(11) % Extra2
% for ex1=1:Kd{n}(10) % Extra1
% for mix=1:Kd{n}(9)  % Locations
% for loc=1:Kd{n}(8)  % Mixes
% for ech=1:Kd{n}(7)  % Echoes
%     % Prototyping to do interpolation once
%     TMP=...
%     [interp1qr(MR.UMCParameters.SystemCorrections.GirfTime,k_accumulated(:,1),MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)) ...
%     interp1qr(MR.UMCParameters.SystemCorrections.GirfTime,k_accumulated(:,2),MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)) ...
%     zeros(numel(MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)),1)]';
%         
%     TMP_nom=...
%     [interp1qr(MR.UMCParameters.SystemCorrections.GirfTime,k_accumulated_nom(:,1),MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)) ...
%     interp1qr(MR.UMCParameters.SystemCorrections.GirfTime,k_accumulated_nom(:,2),MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)) ...
%     zeros(numel(MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech)),1)]';
% for ph=1:Kd{n}(6)   % Phases
% for dyn=1:Kd{n}(5)  % Dynamics
% for z=1:Kd{n}(3)    % Z
%     
%     Kpos{n}(:,:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)=...
%     permute(cat(3,cos(MR.Parameter.Gridder.RadialAngles{n}(:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)')*TMP(1,:),...
%     sin(MR.Parameter.Gridder.RadialAngles{n}(:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)')*TMP(2,:),...
%     zeros(Kd{n}(2),1)*TMP(3,:)),[2 3 1]);
% 
%     Kpos_nom{n}(:,:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)=...
%     permute(cat(3,cos(MR.Parameter.Gridder.RadialAngles{n}(:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)')*TMP_nom(1,:),...
%     sin(MR.Parameter.Gridder.RadialAngles{n}(:,:,z,1,dyn,ph,ech,loc,mix,ex1,ex2)')*TMP_nom(2,:),...
%     zeros(Kd{n}(2),1)*TMP_nom(3,:)),[2 3 1]);
% 
% end % Z
% end % Dynamics
% end % Echos
% end % Phases
% end % Mixes
% end % Locations
% end % Extra1
% end % Extra2
% end % Data chunks
% 
% % Scale to match the requirements of the gridders
% Kpos=cellfun(@(x) permute(.5*x/max(abs(x(:))),[2 1 3 4 5 6 7 8 9 10 11 12]),Kpos,'UniformOutput',false);
% Kpos_nom=cellfun(@(x) permute(.5*x/max(abs(x(:))),[2 1 3 4 5 6 7 8 9 10 11 12]),Kpos_nom,'UniformOutput',false);
% 
% % Visualization
% if MR.UMCParameters.ReconFlags.Verbose
%     subplot(337);for n=1:num_data;for ech=1:Kd{n}(7);
%             M1=Kpos{n}(1,:,1,1,1,1,ech);M2=Kpos{n}(2,:,1,1,1,1,ech);N1=Kpos_nom{n}(1,:,1,1,1,1,ech);N2=Kpos_nom{n}(2,:,1,1,1,1,ech);
%             plot(MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech),sqrt(M1.*conj(M1)+M2.*conj(M2)),'k','Linewidth',2);hold on;
%             plot(MR.UMCParameters.SystemCorrections.GirfADCTime{n}(:,ech),sqrt(N1.*conj(N1)+N2.*conj(N2)),'r--','Linewidth',2);hold on;end;end;grid on;box on;
% 
%             axis([MR.UMCParameters.SystemCorrections.GirfADCTime{1}(1,1) MR.UMCParameters.SystemCorrections.GirfADCTime{num_data}(end,Kd{num_data}(7)) 0 0.75 ]);
%             title('Corrected vs nominal K-space trajectory');legend('Corrected','Nominal');xlabel('Time [ms]');ylabel('K-space cycles/m');set(gca,'LineWidth',2,'FontSize',12,'FontWeight','bold');
% end
% 
% % Use nominal trajectory if required
% if strcmpi(MR.UMCParameters.SystemCorrections.GirfNominalTrajectory,'yes')
%     Kpos=Kpos_nom;
% end
% 
% % Assign trajectory & Apply spatial resolution factor
% MR.Parameter.Gridder.Kpos=cellfun(@(x) x*MR.UMCParameters.AdjointReconstruction.SpatialResolutionRatio,...
%     Kpos,'UniformOutput',false);

% END
end